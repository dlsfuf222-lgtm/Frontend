아주 좋은 예제입니다. 이 코드는 **"렉시칼 스코프(Lexical Scope)"와 "클로저(Closure)"를 동시에 설명하는 교과서적인 코드**입니다.
말씀하신 혼란 지점("inner는 전역에서 호출되는데 왜 상위 스코프가 outer인가?")을 중심으로 **개념 → 코드 매핑 → 실행 흐름** 순서로 정리해 드리겠습니다.

---

## 1️⃣ 렉시칼 스코프란 무엇인가 (한 줄 정의)

> **함수가 '어디서 호출되었는지'가 아니라,
> '어디에서 선언(정의)되었는지'에 따라 상위 스코프가 결정되는 규칙**

✔ 자바스크립트는 **동적 스코프가 아니라 렉시칼(정적) 스코프**를 사용합니다.

---

## 2️⃣ 코드 구조로 본 렉시칼 스코프

```js
function outer(value, callback) {
  let temp = value;
  let cb = callback;

  return function inner(para) {      
      temp = temp + cb(para);
      console.log("🚀 ~ add:", temp);
      return temp;
  }
}
```

### 📌 스코프 구조는 "코드 작성 시점"에 이미 고정됨

```text
[Global Scope]
 ├─ outer
 │   ├─ temp
 │   ├─ cb
 │   └─ inner   ← 여기서 정의됨!
```

👉 **inner 함수는 outer 함수 안에서 선언됨**
👉 그래서 inner의 상위 스코프는 **무조건 outer**

❗ **호출 위치는 전혀 고려 대상이 아님**

---

## 3️⃣ 실행 흐름으로 보면 더 명확해짐

### ① `outer(3, caba)` 호출

```js
const innerFn = outer(3, caba);
```

이 순간에 일어나는 일:

```text
outer 실행 컨텍스트 생성
  value = 3
  callback = caba
  temp = 3
  cb = caba
```

그리고…

```js
return inner;
```

✔ `inner` 함수 **자체**가 반환됨
✔ BUT inner는 **outer의 스코프를 참조한 상태로 반환됨**

➡️ 이것이 바로 **클로저(Closure)**

---

## 4️⃣ inner를 전역에서 호출해도 outer가 상위 스코프인 이유

```js
let ret = innerFn(5); // 전역에서 호출
```

여기서 헷갈리기 쉬운 포인트 👇

> ❌ inner를 전역에서 호출했으니까 상위 스코프는 전역?
>
> ✅ **아니다. inner는 outer 안에서 정의되었기 때문에 상위 스코프는 outer**

### inner 실행 시 스코프 체인

```text
inner Execution Context
 ├─ para = 5
 ├─ (없음) temp → outer로 이동
 ├─ (없음) cb   → outer로 이동
 └─ (없음) caba → global로 이동
```

즉,

```js
temp = temp + cb(para);
```

는 실제로 이렇게 해석됨:

```js
outer.temp = outer.temp + outer.cb(para);
```

---

## 5️⃣ 그래서 이 줄이 핵심이다

```js
temp = temp + cb(para);  
```

### ✔ 이 한 줄이 증명하는 것

* `temp`와 `cb`는 **inner 내부에 없음**
* 하지만 **에러가 나지 않고 정상 동작**
* 이유는?

  * inner가 **자신이 선언된 위치의 스코프(outer)를 기억**하고 있기 때문

➡️ **렉시칼 스코프 + 클로저의 결정적 증거**

---

## 6️⃣ 결과 값이 누적되는 이유 (클로저 특성)

```js
const innerFn = outer(3, caba);

innerFn(5); // 3 + (10 + 5) = 18
innerFn(1); // 18 + (10 + 1) = 29
```

### 이유

* `outer`의 실행 컨텍스트는 끝났지만
* `inner`가 `temp`, `cb`를 참조 중
* → GC 대상이 되지 않음
* → 상태 유지

📌 **클로저 = 사라져야 할 스코프가 살아남는 현상**

---

## 7️⃣ 한 문장으로 요약 (면접용)

> **inner 함수는 전역에서 호출되었지만,
> outer 안에서 선언되었기 때문에 outer를 상위 스코프로 삼는다.
> 이는 자바스크립트가 렉시칼 스코프를 사용하기 때문이다.**

---

## 8️⃣ 이 코드가 "렉시칼 스코프 설명 최적"인 이유

✔ 호출 위치가 전역임에도
✔ 선언 위치가 outer이기 때문에
✔ outer의 지역 변수를 정상 참조
✔ 심지어 상태까지 유지

👉 **동적 스코프였다면 이 코드는 동작하지 않음**

---

원하시면

* ❌ 동적 스코프였다면 어떻게 깨지는지
* 🔥 `this`와 렉시칼 스코프의 차이
* 🧠 V8이 클로저를 메모리에 어떻게 유지하는지

이 중 하나 더 깊게 파드릴 수 있습니다.
